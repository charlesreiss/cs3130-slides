\date{}
\title{}
\date{}
\begin{document}
\begin{frame}
    \titlepage
\end{frame}

\input{../common/listingsLib}
\begin{frame}{last time}
    \begin{itemize}
    \item passing values to/from threads
    \item detach
    \item race conditions and interleaving
    \item what is/is not atomic
    \end{itemize}
\end{frame}

\subsection{example: x86 add not atomic}
\input{../sync/lost-add-example}

\subsection{what is atomic?}
\input{../sync/what-atomic}

\section{revisiting atomicity}
\subsection{compiler reordering}
\input{../sync/compiler-reordering}

\subsection{fix compiler reordering}
\begin{frame}{fixing compiler reordering?}
    \begin{itemize}
    \item isn't there a way to tell compiler not to do these optimizations?
    \item yes, but that is \myemph{still not enough}!
    \item \textbf{processors} sometimes do this kind of reordering too (between cores)
    \end{itemize}
\end{frame}

\section{pthreads and load/store reordering}
\input{../sync/no-reordering}

\section{definitions: mutual exclusion, critical section}
\input{../sync/mutual-exclusion-defn}

\section{locks}
\input{../sync/lock-analogy}

% FIXME: lock analogy: hat
\input{../sync/locks}

\subsection{exercise}
\input{../sync/lock-ex}

\subsection{pthread\_mutex: lock where you unlock}
\input{../sync/pthread-mutex-restriction}

\section{preview: more advance sync}
\input{../sync/preview-dont-roll}

\subsection{beyond locks}
\input{../sync/beyond-lock}

\input{../deadlock/talk-inner}

\section{backup slides}
\begin{frame}{backup slides}
\end{frame}

\end{document}
