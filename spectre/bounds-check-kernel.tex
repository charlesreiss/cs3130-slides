\begin{frame}[fragile]{really contrived?}
\begin{lstlisting}[language=C,style=smaller]
char *array1; char *array2;
if (x < array1_size)
    y = array2[array1[x] * 4096];
\end{lstlisting}
\begin{itemize}
\item times 4096 shifts so we can get lower bits of target value
    \begin{itemize}
    \item so all bits effect what cache block is used
    \end{itemize}
\end{itemize}
\hrule
\begin{visibleenv}<2->
\begin{lstlisting}[language=C,style=smaller]
int *array1; int *array2;
if (x < array1_size)
    y = array2[array1[x]];
\end{lstlisting}
\begin{itemize}
\item will still get \textit{upper} bits of array1[x] (can tell from cache set)
    \begin{itemize}
        \item still likely to be sensitive data
    \end{itemize}
\end{itemize}
\end{visibleenv}
\end{frame}

\begin{frame}[fragile]{bounds check in kernel}
\lstset{
    language=C,
    style=small,
    moredelim={**[is][\btHL<2>]{@2}{2@}},
    moredelim={**[is][\btHL<3>]{@3}{3@}},
    moredelim={**[is][\btHL<4>]{@4}{4@}},
    moredelim={**[is][\btHL<5>]{@5}{5@}},
}
\begin{lstlisting}
void SomeSystemCallHandler(int index) {
    if (@2index > some_table_size2@) 
        return ERROR;
    int kind = @3table[index]3@;
    switch (@4other_table[kind].foo4@) {
        ...
    }
}
\end{lstlisting}
\hrule
\begin{lstlisting}
if (@2x < array1_size2@) {
    y = @4array2[@3array1[x]3@]4@;
}
\end{lstlisting}
\end{frame}

\begin{frame}\frametitle{generalizing exploit}
    \begin{itemize}
    \item limited in what address we can learn about based on how big entries in tables are
        \begin{itemize}
        \item but can combine multiple Spectre-type exploits
        \item only need one secret value leaked
        \end{itemize}
    \item need to adjust calculations to actual addresses / array element sizes / etc.
    \end{itemize}
\end{frame}
