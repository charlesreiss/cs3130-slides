\begin{frame}{blocking signals}
\begin{itemize}
\item avoid having signal handlers anywhere:
\item can instead \myemph{block signals}
\vspace{.5cm}
\item can be done with {\tt sigprocmask} or {\tt pthread\_sigmask} 
\item signal will become ``pending'' instead
\item OS will not deliver unless unblocked
    \begin{itemize}
    \item similar mechanism provided by CPU for interrupts (``disabling interrupts'')
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{controlling when signals are handled}
\begin{itemize}
\item first, block a signal
\item then use system calls to inspect pending signals
    \begin{itemize}
    \item example: {\tt sigwait}
    \end{itemize}
\item and/or unblock signals only at certain times
    \begin{itemize}
        \item some special functions to help: \\ {\tt sigsuspend} (unblock until handler runs), \\ {\tt pselect} (unblock while checking for I/O), \ldots
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile,label=syncSig]{synchronous signal handling}
\lstset{language=C,style=small}
\begin{lstlisting}
int main(void) {
    sigset_t set;
    sigemptyset(&set);
    sigaddset(&set, SIGINT);
    sigprocmask(SIG_BLOCK, &set, NULL);
    
    printf("Waiting for SIGINT (control-C)\n"); 
    if (sigwait(&set, NULL) == SIGINT) {
        printf("Got SIGINT\n");
    }
}
\end{lstlisting}
\end{frame}

