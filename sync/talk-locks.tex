\section{introduction: correctness}
\input{../threads/pthread-create-race-lib}
\againframe<1>{pthreadCreateBrokenP}

\againframe<1>{pthreadCreateRace}
\input{../sync/the-correctness-problem}

\section{the lost write}

\subsection{motivation: threaded ATM server?}
\input{../sync/lost-write-motivate-atm-server}

\subsection{example}
\input{../sync/lost-write}

\section{race conditions and atomicity}
\subsection{thinking about simple races} 
\input{../sync/simple-races}

\subsection{atomicity definition}
\input{../sync/atomicity}

\subsection{example: x86 add not atomic}
\input{../sync/lost-add-example}

\subsection{what is atomic?}
\input{../sync/what-atomic}

\section{revisiting atomicity}
\subsection{compiler reordering}
\input{../sync/compiler-reordering}

\subsection{fix compiler reordering}
\begin{frame}{fixing compiler reordering?}
    \begin{itemize}
    \item isn't there a way to tell compiler not to do these optimizations?
    \item yes, but that is \myemph{still not enough}!
    \item \textbf{processors} sometimes do this kind of reordering too (between cores)
    \end{itemize}
\end{frame}

\section{pthreads and load/store reordering}
\input{../sync/no-reordering}

\section{definitions: mutual exclusion, critical section}
\input{../sync/mutual-exclusion-defn}

\section{locks}
\input{../sync/lock-analogy}

% FIXME: lock analogy: hat
\input{../sync/locks}

\subsection{exercise}
\input{../sync/lock-ex}

\subsection{pthread\_mutex: lock where you unlock}
\input{../sync/pthread-mutex-restriction}

\section{preview: more advance sync}
\input{../sync/preview-dont-roll}

\subsection{beyond locks}
\input{../sync/beyond-lock}

\section{barriers}
\input{../sync/barriers}

\section{life HW}
\input{../sync/life-hw-intro}


