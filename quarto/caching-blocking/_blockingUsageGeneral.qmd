
### array usage: block 



::: {.r-stack .my-full}
![](/caching-blocking/texfig/cacheBlockBlockGeneral.figure-1.svg){.fragment .fade-in-then-out fragment-index=1}

![](/caching-blocking/texfig/cacheBlockBlockGeneral.figure-2.svg){.fragment .fade-in-then-out fragment-index=2}

![](/caching-blocking/texfig/cacheBlockBlockGeneral.figure-3.svg){.fragment .fade-in-then-out fragment-index=3}

![](/caching-blocking/texfig/cacheBlockBlockGeneral.figure-4.svg){.fragment .fade-in-then-out fragment-index=4}


:::


### cache blocking efficiency  {.smaller}


* load $I\\times{} K$ elements of $A_ik$:  

   * do $>J$ multiplies with each

* load $K\\times{} J$ elements of $A_kj$:  

   * do $I$ multiplies with each

* load $I\\times{} J$ elements of $B_ij$: 

   * do $K$ adds with each

* bigger blocks --- more work per load!
* catch: $IK+KJ+IJ$ elements must fit in cache


### cache blocking rule of thumb  {.smaller}


* fill the <em>most of the cache with useful data</em>
* and do as much work as possible from that
* example: my desktop 32KB L1 cache
* $I=J=K=48$ uses $48^2\\times{} 3$ elements, or $27$KB.
* assumption: conflict misses aren't important

