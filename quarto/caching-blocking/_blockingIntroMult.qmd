
### simple blocking -- counting loads  {.smaller}

<!-- \lstset{
    style=small,language=C,escapechar=@,
    moredelim=**[is][\btHL<0>]{~2}{~},
    moredelim=**[is][\btHL<0>]{~3}{~},
    moredelim=**[is][\btHL<0>]{~4}{~},
} -->
 
<pre><code>for (int kk = 0; kk &lt; N; kk += 2)
  for (int i = 0; i &lt; N; ++i)
    /* load A_i,kk and A_i,kk+1 once into cache in this loop: */
    for (int j = 0; j &lt; N; ++j) {
      /* process a "block" of 2 k values: */
      /* if N large, load Cij and Bkj each iteration: */
      <span data-fragment-index="0" class="fragment custom myem-only">C[i*N+j]</span> += <span data-fragment-index="0" class="fragment custom myem-only">A[i*N+kk+0]</span> * <span data-fragment-index="0" class="fragment custom myem-only">B[(kk+0)*N+j]</span>;
      <span data-fragment-index="0" class="fragment custom myem-only">C[i*N+j]</span> += <span data-fragment-index="0" class="fragment custom myem-only">A[i*N+kk+1]</span> * <span data-fragment-index="0" class="fragment custom myem-only">B[(kk+1)*N+j]</span>;
    }
</code></pre>
 

* (if $N$ large) values from $A_ik$ used $N$ times per load 

   * [but $A_i,k$ and $A_i,k+1$ in same cache block: one load for each]{.fragment fragment-index=1 .custom .myem-only}

* (if $N$ large) values from $B_kj$ used $1$ times per load 

   * but good spatial locality, so cache block of $B_kj$ together

* (if $N$ large) values from $C_ij$ used [$2$]{.fragment fragment-index=2 .custom .myem-only} times per load 

   * but good spatial locality, so cache block of $C_ij$ together



### improvement in read misses 


![](/caching-blocking/k-kk-novec-block-read_miss_rate.svg){}

