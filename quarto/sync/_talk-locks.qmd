
{{< include /sync/_the-correctness-problem.qmd >}}

# the lost write {visibility="hidden"}

## motivation: threaded ATM server? {visibility="hidden"}

{{< include /sync/_lost-write-motivate-atm-server.qmd >}}

## example {visibility="hidden"}

{{< include /sync/_lost-write.qmd >}}

# race conditions and atomicity {visibility="hidden"}

## thinking about simple races {visibility="hidden"}

{{< include /sync/_simple-races.qmd >}}

## atomicity definition {visibility="hidden"}

{{< include /sync/_atomicity.qmd >}}

## example: x86 add not atomic {visibility="hidden"}

{{< include /sync/_lost-add-example.qmd >}}

## what is atomic? {visibility="hidden"}

{{< include /sync/_what-atomic.qmd >}}

# revisiting atomicity {visibility="hidden"}

## compiler reordering {visibility="hidden"}

{{< include /sync/_compiler-reordering.qmd >}}

## fix compiler reordering {visibility="hidden"}

### fixing compiler reordering? 


* isn't there a way to tell compiler not to do these optimizations?
* yes, but that is <em>still not enough</em>!
* <em>processors</em> sometimes do this kind of reordering too (between cores)


# pthreads and load/store reordering {visibility="hidden"}

{{< include /sync/_no-reordering.qmd >}}

# definitions: mutual exclusion, critical section {visibility="hidden"}

{{< include /sync/_mutual-exclusion-defn.qmd >}}

# locks {visibility="hidden"}

{{< include /sync/_lock-analogy.qmd >}}

{{< include /sync/_locks.qmd >}}

## exercise {visibility="hidden"}

{{< include /sync/_lock-ex.qmd >}}

## pthread_mutex: lock where you unlock {visibility="hidden"}

{{< include /sync/_pthread-mutex-restriction.qmd >}}

# preview: more advance sync {visibility="hidden"}

{{< include /sync/_preview-dont-roll.qmd >}}

## beyond locks {visibility="hidden"}

{{< include /sync/_beyond-lock.qmd >}}
