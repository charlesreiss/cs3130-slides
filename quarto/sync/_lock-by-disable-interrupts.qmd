
### implementing locks: single core  {.smaller}


* intuition: context switch only happens on interrupt 

   * timer expiration, I/O, etc. causes OS to run

* solution: disable them 

   * reenable on unlock

* x86 instructions: 

   * <code>cli</code> --- disable interrupts
   * <code>sti</code> --- enable interrupts



### naive interrupt enable/disable (1)  {.smaller}

![](/sync/texfig/naiveEnableDisable1.figure.svg)
 

* problem: user can <em>hang the system</em>: 
<pre><code>            Lock(some_lock);
            while (true) {}
</code></pre>

* problem: can't do I/O within lock 
<pre><code>            Lock(some_lock);
            read from disk
                /* waits forever for (disabled) interrupt
                   from disk IO finishing */
</code></pre>



### naive interrupt enable/disable (2)  {.smaller}

![](/sync/texfig/naiveEnableDisable2.figure.svg)
 

* problem: nested locks 
<pre><code>        Lock(milk_lock);
        if (no milk) {
            Lock(store_lock);
            buy milk
            Unlock(store_lock);
            /* interrupts enabled here?? */
        }
        Unlock(milk_lock);
</code></pre>


