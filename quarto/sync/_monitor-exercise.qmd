
### monitor exercise: ConsumeTwo  {.smaller}



* suppose we want producer/consumer, but…
* but change Consume() to ConsumeTwo() which returns a <em>pair of values</em> 

   * and don't want two calls to ConsumeTwo() to wait…
   * with each getting one item

* what should we change below?
 
:::: {.columns}

::: {.column width="45%"}
 
<pre><code>pthread_mutex_t lock;
pthread_cond_t data_ready;
UnboundedQueue buffer;

Produce(item) {
  pthread_mutex_lock(&amp;lock);
  buffer.enqueue(item);
  pthread_cond_signal(&amp;data_ready);
  pthread_mutex_unlock(&amp;lock);
}
</code></pre>
 
:::

::: {.column width="45%"}
 
<pre><code>Consume() {
  pthread_mutex_lock(&amp;lock);
  while (buffer.empty()) {
    pthread_cond_wait(&amp;data_ready, &amp;lock);
  }
  item = buffer.dequeue();
  pthread_mutex_unlock(&amp;lock);
  return item;
}
</code></pre>
 
:::

::::


<!-- \iftoggle(heldback,isheldback,isheldback) -->

### monitor exercise: solution (1)  {.smaller}

[]{.my-small} (one of many possible solutions) <br> Assuming ConsumeTwo <em>replaces</em> Consume: 
```
Produce() {
  pthread_mutex_lock(&lock);
  buffer.enqueue(item);
  if (buffer.size() > 1) { pthread_cond_signal(&data_ready); }
  pthread_mutex_unlock(&lock);
}
ConsumeTwo() {
    pthread_mutex_lock(&lock);
    while (buffer.size() < 2) { pthread_cond_wait(&data_ready, &lock); }
    item1 = buffer.dequeue(); item2 = buffer.dequeue();
    pthread_mutex_unlock(&lock);
    return Combine(item1, item2);
}

```


### monitor exercise: solution (2)  {.smaller}

[]{.my-small} (one of many possible solutions) <br> Assuming ConsumeTwo is <em>in addition to</em> Consume (using two CVs): 
```
Produce() {
  pthread_mutex_lock(&lock);
  buffer.enqueue(item);
  pthread_cond_signal(&one_ready);
  if (buffer.size() > 1) { pthread_cond_signal(&two_ready); }
  pthread_mutex_unlock(&lock);
}
Consume() {
  pthread_mutex_lock(&lock);
  while (buffer.size() < 1) { pthread_cond_wait(&one_ready, &lock); }
  item = buffer.dequeue();
  pthread_mutex_unlock(&lock);
  return item;
}
ConsumeTwo() {
  pthread_mutex_lock(&lock);
  while (buffer.size() < 2) { pthread_cond_wait(&two_ready, &lock); }
  item1 = buffer.dequeue(); item2 = buffer.dequeue();
  pthread_mutex_unlock(&lock);
  return Combine(item1, item2);
}

```


### monitor exercise: slower solution  {.smaller}

[]{.my-small} (one of many possible solutions) <br> Assuming ConsumeTwo is <em>in addition to</em> Consume (using one CV): 
```
Produce() {
  pthread_mutex_lock(&lock);
  buffer.enqueue(item);
  // broadcast and not signal, b/c we might wakeup only ConsumeTwo() otherwise
  pthread_cond_broadcast(&data_ready);
  pthread_mutex_unlock(&lock);
}
Consume() {
  pthread_mutex_lock(&lock);
  while (buffer.size() < 1) { pthread_cond_wait(&data_ready, &lock); }
  item = buffer.dequeue();
  pthread_mutex_unlock(&lock);
  return item;
}
ConsumeTwo() {
  pthread_mutex_lock(&lock);
  while (buffer.size() < 2) { pthread_cond_wait(&data_ready, &lock); }
  item1 = buffer.dequeue(); item2 = buffer.dequeue();
  pthread_mutex_unlock(&lock);
  return Combine(item1, item2);
}

```

