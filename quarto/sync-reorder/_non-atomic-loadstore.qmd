
### a simple race  {.smaller}


:::: {.columns}

::: {.column width="45%"}
 
```gnuassembler
thread_A:
    movl $1, x   /* x <- 1 */
    movl y, %eax /* return y */
    ret

```
 
:::

::: {.column width="45%"}
 
```gnuassembler
thread_B:
    movl $1, y   /* y <- 1 */
    movl x, %eax /* return x */
    ret

```
 
:::

::::


```c
x = y = 0;
pthread_create(&A, NULL, thread_A, NULL);
pthread_create(&B, NULL, thread_B, NULL);
pthread_join(A, &A_result); pthread_join(B, &B_result);
printf("A:%d B:%d\n", (int) A_result, (int) B_result);

```

* if loads/stores atomic, then possible results: 

   * A:1 B:1 --- both moves into x and y, then both moves into eax execute
   * A:0 B:1 --- thread A executes before thread B
   * A:1 B:0 --- thread B executes before thread A



### a simple race: results  {.smaller}


:::: {.columns}

::: {.column width="45%"}
 
```gnuassembler
thread_A:
    movl $1, x   /* x <- 1 */
    movl y, %eax /* return y */
    ret

```
 
:::

::: {.column width="45%"}
 
```gnuassembler
thread_B:
    movl $1, y   /* y <- 1 */
    movl x, %eax /* return x */
    ret

```
 
:::

::::

```c
x = y = 0;
pthread_create(&A, NULL, thread_A, NULL);
pthread_create(&B, NULL, thread_B, NULL);
pthread_join(A, &A_result); pthread_join(B, &B_result);
printf("A:%d B:%d\n", (int) A_result, (int) B_result);

```
my desktop, 100M trials: <br> <table>
<tr><th>frequency</th><th>result</th><td>&nbsp;</td></tr>
<tr><td>$99\,823\,739$</td><td>A:0 B:1</td><td>(‘A executes before B’)</td></tr>
<tr><td>$171\,161$</td><td>A:1 B:0</td><td>(‘B executes before A’)</td></tr>
<tr><td>$4\,706$</td><td>A:1 B:1</td><td>(‘execute moves into x+y first’)</td></tr>
<tr><td>[$394$]{.fragment fragment-index=2 .custom .myem-only}</td><td>[A:0 B:0]{.fragment fragment-index=2 .custom .myem-only}</td><td>[???]{.fragment fragment-index=2 .custom .myem-only}</td></tr>
<tr><td></td></tr>
</table>

