
### C and cache misses (3)  {.smaller}


```c
typedef struct {
    int a_value, b_value;
    int other_values[10];
} item;
item items[5];
int a_sum = 0, b_sum = 0;
for (int i = 0; i < 5; ++i)
    a_sum += items[i].a_value;
for (int i = 0; i < 5; ++i)
    b_sum += items[i].b_value;
```
 

* observation: 12 ints in struct: only first two used
* equivalent to accessing array[0], array[12], array[24], etc.
* â€¦ then accessing array[1], array[13], array[25], etc.


### C and cache misses (3, rewritten?)  {.smaller}


```c
int array[60];
int a_sum = 0, b_sum = 0;
for (int i = 0; i < 60; i += 12)
    a_sum += array[i];
for (int i = 1; i < 60; i += 12)
    b_sum += array[i];
```
 

* [Assume everything but <code>array</code> is kept in registers (and the compiler does not do anything funny) and array at beginning of cache block.]{.my-small}
* How many <i>data cache misses</i> on a 128B two-way set associative cache with 16B cache blocks and LRU replacement?
* observation 1: first loop has 5 misses --- first accesses to blocks
* observation 2: array[0] and array[1], array[12] and array[13], etc. in same cache block


### C and cache misses (3, solution)  {.smaller}


* ints 4 byte $\rightarrow{}$ array[0 to 3] and array[16 to 19] in same cache set 

   * 64B = 16 ints stored per way
   * 4 sets total

* accessing array indices 0, 12, 24, 36, 48, 1, 13, 25, 37, 49
* 0 (set 0, array[0 to 3]), 12 (set 3), 24 (set 2), 36 (set 1), 48 (set 0) 

   * each set used at most twice
   * no replacement needed

* so access to 1, 21, 41, 61, 81 all hits: 

   * set 0 contains block with array[0 to 3]
   * set 5 contains block with array[20 to 23]
   * etc.


