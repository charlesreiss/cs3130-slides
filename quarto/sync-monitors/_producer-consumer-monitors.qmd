
### bounded buffer producer/consumer --- full code {.smaller}

```{.c code-line-numbers="true"}
{{< include /sync-monitors/bounded-producer-consumer.c >}}
```


### bounded buffer p/c--- added {.smaller}

```{.c code-line-numbers="3,7-9,20"}
{{< include /sync-monitors/bounded-producer-consumer.c >}}
```

::: {.myoverbox .fragment fragment-index=1 .midright}

add new condition variable<br/>
for new reason to wait

wait on that condition</br>
while reason to wait is true

signal that condition<br/>
when one thread can stop waiting

:::

### bounded buffer p/c --- signal/broadcast {.smaller}

```{.c code-line-numbers="20"}
{{< include /sync-monitors/bounded-producer-consumer.c >}}
```

::: {.myoverbox .fragment fragment-index=1 .high}

`signal` better than `broadcast` in this case<br/>
only one waiting thread can do something useful

correct (but slow) to `broadcast` instead

:::

### bounded buffer p/c --- signal/broadcast {.smaller}

```{.c code-line-numbers="true"}
{{< include /sync-monitors/bounded-producer-consumer.c >}}
```

:::: {.myoverbox .fragment fragment-index=1 .midright style="width: 45%"}

correct but slow to use just one condition variable:

::: {style="font-size: 80%"}

*  `data_ready`, `space_ready` $\Rightarrow$ `ready`

*  always use `broadcast` 
   *  let each thread figure out if it was supposed to be woken up

:::

::::
