
### pthread cv usage {.smaller}

```{.c code-line-numbers=true}
{{< include /sync-monitors/wait-for-finished.c >}}
```


### pthread cv usage --- lock first {.smaller}

```{.c code-line-numbers="7,15"}
{{< include /sync-monitors/wait-for-finished.c >}}
```

::: {.myoverbox .low}

acquire lock before reading or write `finished`

:::

### pthread cv usage --- check waiting? {.smaller}

```{.c code-line-numbers="8"}
{{< include /sync-monitors/wait-for-finished.c >}}
```

::: {.myoverbox .low}

check whether we need to wait at all

yes, must be a loop --- we'll explain later

:::


### pthread cv usage --- do waiting {.smaller}

```{.c code-line-numbers="9"}
{{< include /sync-monitors/wait-for-finished.c >}}
```

::: {.myoverbox .low}

know we need to wait<br />
[(`finished` cannot have changed since we checked because of lock)]{.my-small}

so wait releasing lock<br/>
important that we release lock, so `finished` can change

:::

### pthread cv usage --- broadcast {.smaller}

```{.c code-line-numbers="17"}
{{< include /sync-monitors/wait-for-finished.c >}}
```

::: {.myoverbox .vlow}

all waiters to proceed once we release lock

:::




### WaitForFinish timeline 1  {.smaller}

<table style="font-size: 80%">
<tr><th>WaitForFinish thread</th><th>Finish thread</th></tr>
<tr><td> `mutex_lock(&lock)`</td><td></td></tr>
<tr><td>(thread has lock)</td><td></td></tr>
<tr><td> &nbsp;</td><td>`mutex_lock(&lock)`</td></tr>
<tr><td>&nbsp;</td><td>(start waiting for lock)</td></tr>
<tr><td> `while (!finished) ...`</td><td></td></tr>
<tr><td>`cond_wait(&finished_cv, &lock);`</td><td></td></tr>
<tr><td>(start waiting for cv)</td><td>(done waiting for lock)</td></tr>
<tr><td> &nbsp;</td><td>`finished = true`</td></tr>
<tr><td>&nbsp;</td><td>`cond_broadcast(&finished_cv)`</td></tr>
<tr><td> (done waiting for cv)</td><td>&nbsp;</td></tr>
<tr><td>(start waiting for lock)</td><td>&nbsp;</td></tr>
<tr><td> &nbsp;</td><td>`mutex_unlock(&lock)`</td></tr>
<tr><td> (done waiting for lock)</td></tr>
<tr><td>`while (!finished) ...`</td><td></td></tr>
<tr><td>(finished now true, so return)</td></tr>
<tr><td>`mutex_unlock(&lock)`</td></tr>
<tr><td></td></tr>
</table>


### WaitForFinish timeline 2  {.smaller}

<!-- \lstset{language=C++,style=smaller} -->
 []{.my-small}  
 <table>
<tr><th>WaitForFinish thread</em></th><th>Finish thread</th></tr>
<tr><td> &nbsp;</td><td>`mutex_lock(&lock)`</td></tr>
<tr><td>&nbsp;</td><td>`finished = true`</td></tr>
<tr><td>&nbsp;</td><td>`cond_broadcast(&finished_cv)`</td></tr>
<tr><td>&nbsp;</td><td>`mutex_unlock(&lock)`</td></tr>
<tr><td> `mutex_lock(&lock)`</td><td></td></tr>
<tr><td>`while (!finished) ...`</td><td></td></tr>
<tr><td>(finished now true, so return)</td></tr>
<tr><td>`mutex_unlock(&lock)`</td></tr>
<tr><td></td></tr>
</table>


### why the loop  {.smaller}


```c
while (!finished) {
  pthread_cond_wait(&finished_cv, &lock);
}

```
 

* we only <code>broadcast</code> if <code>finished</code> is true
* so why check <code>finished</code> afterwards? 
<hr class="vspace" />
* pthread_cond_wait manual page:  

   * ‘‘<em>Spurious wakeups</em> ... may occur.’’

* spurious wakeup = <code>wait</code> returns even though nothing happened

