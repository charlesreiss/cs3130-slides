### unbounded buffer producer/consumer {.smaller}

```{.c code-line-numbers=true}
{{< include /sync-monitors/unbounded-producer-consumer.c >}}
```

### unbounded p/c --- lock {.smaller}

```{.c code-line-numbers="5,8,11,16"}
{{< include /sync-monitors/unbounded-producer-consumer.c >}}
```

::: {.myoverbox .vlow}

rule: never touch `buffer` without acquiring lock

otherwise: what if two threads simulatenously en/dequeue?

:::

### unbounded p/c --- dequeue if empty {.smaller}

```{.c code-line-numbers="12,16"}
{{< include /sync-monitors/unbounded-producer-consumer.c >}}
```

::: {.myoverbox .vlow}

check if empty, then dequeue

(note: have lock --- don't need to worry about someone else dequeuing)

:::

### unbounded p/c --- wake {.smaller}

```{.c code-line-numbers=""}
{{< include /sync-monitors/unbounded-producer-consumer.c >}}
```

::: {.myoverbox .vlow}

check if empty (waiting if needed), then dequeue

(note: have lock --- don't need to worry about someone else dequeuing)

:::


### unbounded p/c --- wake {.smaller}

```{.c code-line-numbers="7"}
{{< include /sync-monitors/unbounded-producer-consumer.c >}}
```

::: {.myoverbox .vlow}

after enqueuing<br/>
wake one Consume thread (if any are waiting)

:::

### unbounded p/c --- waiting {.smaller}

```{.c code-line-numbers="12-14"}
{{< include /sync-monitors/unbounded-producer-consumer.c >}}
```

::: {.myoverbox .highright .fragment .fade-in-then-out fragment-index=5}

while loop could run 0 times

<table class="collines">
<tr><th>Thread 1</th><th>Thread 2</th></tr>
<tr><td>Produce()</td><td></td></tr>
<tr><td>... lock</td><td></td></tr>
<tr><td>... enqueue</td><td></td></tr>
<tr><td>... signal</td><td></td></tr>
<tr><td>... unlock</td><td></td></tr>
<tr><td></td><td>Consume?</td></tr>
<tr><td></td><td>... lock</td></tr>
<tr><td></td><td>... empty? no</td></tr>
<tr><td></td><td>... dequeue</td></tr>
<tr><td></td><td>... unlock</td></tr>
<tr><td></td><td>return</td></tr>
</table>

:::

::: {.myoverbox .highright .fragment .fade-in-then-out fragment-index=6 style="font-size: 75%"}

while loop could run 1 times

<table class="collines">
<tr><th>Thread 1</th><th>Thread 2</th></tr>
<tr><td></td><td>Consume?</td></tr>
<tr><td></td><td>... lock</td></tr>
<tr><td></td><td>... empty? yes</td></tr>
<tr><td></td><td>... unlock/start wait</td></tr>
<tr><td>Produce()</td><td></td></tr>
<tr><td>... lock</td><td></td></tr>
<tr><td>... enqueue</td><td></td></tr>
<tr><td>... signal</td><td>stop wait</td></tr>
<tr><td>... unlock</td><td>lock</td></tr>
<tr><td></td><td>... empty? no</td></tr>
<tr><td></td><td>... dequeue</td></tr>
<tr><td></td><td>... unlock</td></tr>
<tr><td></td><td>return</td></tr>
</table>

:::

::: {.myoverbox .highright .fragment .fade-in-then-out fragment-index=7 style="font-size: 65%"}

while loop could run 2+ times

<table class="collines">
<tr><th>Thread 1</th><th>Thread 2</th><th>Thread 3</th></tr>
<tr><td></td><td>Consume?</td><td></td></tr>
<tr><td></td><td>... lock</td><td></td></tr>
<tr><td></td><td>... empty? yes</td><td></td></tr>
<tr><td></td><td>... unlock/start wait</td><td></td></tr>
<tr><td>Produce()</td><td></td><td></td></tr>
<tr><td>... lock</td><td></td><td></td></tr>
<tr><td>... enqueue</td><td></td><td></td></tr>
<tr><td>... signal</td><td>stop wait</td><td></td></tr>
<tr><td>... unlock</td><td>lock</td><td></td></tr>
<tr><td></td><td></td><td>Consume?</td></tr>
<tr><td></td><td></td><td>... lock</td></tr>
<tr><td></td><td></td><td>... empty? no</td></tr>
<tr><td></td><td></td><td>... dequeue</td></tr>
<tr><td></td><td></td><td>... unlock</td></tr>
<tr><td></td><td></td><td>return</td></tr>
<tr><td></td><td>... empty? no</td><td></td></tr>
<tr><td></td><td>... dequeue</td><td></td></tr>
<tr><td></td><td>... unlock</td><td></td></tr>
<tr><td></td><td>return</td><td></td></tr>
</table>

:::

